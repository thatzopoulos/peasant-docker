# Peasant-Docker

The Prokaryotic Assembly and Annotation Tool, Peasant, automates the processes of read quality control, genome assembly, and annotation for microbial sequencing projects. Peasant provides an intuitive solution for high-quality whole genome sequence assembly and annotation for users with limited programing experience and/or computational resources.

## Getting Started

Clone project:
```
git clone github.com/thatzopoulos/peasant-docker.git
```

Move files that you want to run to inputFiles if you want to build the image with those files already inside, if not, use the -v flag shown below to mirror a local folder within the Docker image.

From within the project folder run:
```python
sudo docker build -t peasant .
```
```python
sudo docker run -v /pathToLocalFolder/runName:/peasantDockerOutputFolder -i -t peasant
```

To pull up peasant help for parameters while in the docker container:
```python
python3 peasant.py -h
```


Links to Example Databases:
https://drive.google.com/drive/folders/0B3MjIo6BB7_1NGZTN3l4WXl5VEE


For documentation using peasant, refer to [here](https://github.com/jlbren/peasant).

Note: 'peasantDockerOutputFolder' (the folder where Docker expects output to be written) must be the same folder specified when running peasant.py, the -o option.

## Advanced Usage
## Usage: peasant.py [assembly options] [filter options] [database] [homology options] -o output_path


**assembly options:**  
  -a {spades}, --assembler {spades}  
      Assembly methods:  
            spades: spades assembler  
  
  
  -A <filename>, --assembled_contigs <filename>  
      This will start analysis from an existing assembly/ multi-FASTA format file.  
  
  
  -s <filename>, --single_reads <filename>  
      Single reads file (FASTA or FASTQ).  
  -p <filename> <filename>, --paired_end_reads <filename> <filename>  
      Paired-end read files. List both read files (FASTA or FASTQ).  
 
**filter options:**  
  -m <int>, --min_contig_size <int>  
      Minimum contig size.  
  
  
  -M <int>, --max_contig_size <int>  
      Maximum contig size.  
  
  
  -c <int>, --min_coverage <int>  
      Minimum coverage.  
  
  
  -cov <float>, --min_SPAdes_cov <float>  
      Minimum SPAdes cov value.  
   
**database options:**  
  -g <filename>, --genus <filename>  
      Genus name to use for annotation. To consider more than one genus, list genus name (space separator). (required)  
  
  
**homology options:**  
  -q <float>, --qcov <float>  
      Minimum query coverage to call homologous genes. Default=70.0.  
  
  
  -i <float>, --pident <float>  
      Minimum percent identity to call homologous genes. Default=70.0.  
  
  
  -b <float>, --bitscore <float>  
      Minimum bitscore to call homologous genes. Default=50.0.  
  
  
**other options:**  
 -o <directory>, --output_path <directory>  
      Directory to store all the resulting files (required)  
  
  
  -t <int>, --num_threads <int>  
      Number of processors to use. (default=1)  
  
  
  -h, --help  
      Shows help message and exits.  
  
  
  --version  
      Show program's version number and exits.  
  
  
  
  
## Example:  
Let’s say I have paired-end reads R1 and R2. They are for the genome of a novel E. coli species isolated in the lab. I want to output my results to a folder my_output.
  
`python peasant.py -a spades -p /mydirectory/R1.fastq /mydirectory/R2.fastq -g Escherichia -o /mydirectory/my_output`


This will produce the output folder my_output with the following files and directory:  
*Directory temp*: This directory contains all of the temporary files generated by read QC (‘trimmed_<filename>’ and singletons.fastq (in the case of paired-end reads),  the assembly (in the subdirectory /assembly), and coding region prediction.  
*annotations.csv*: comma delimited file listing the contig/location of predicted genes.  
*final_contigs.fasta*: Multi-FASTA format file of the final contigs (after filtering)  
*predicted_orfs.fasta*: all predicted ORFs for the final contigs  
*predicted_orfs_aa.fasta*: Multi-FASTA amino acid sequences for the ORFs predicted within the contigs.  
*predicted_orfs_nt.fasta*: Multi-FASTA nucleotide sequences for the ORFs predicted within the contigs.  
*predicted_rRNAs.fasta*: Multi-FASTA nucleotide sequences for the rRNA (5, 16, and 23) sequences predicted.  
*tRNAscan-SE_output.txt*: output generated by tRNAscan-SE listing the locations and tRNA type found.  
*log.txt*: Log file generated. Includes information about parameters, results of filtering and classification.  
  
  
  
  
Let’s say I’m most interested in finding sequences that are of a certain size, say 20K-80K, I can revise my above function call as follows:  
`python peasant.py -a spades -p /mydirectory/R1.fastq /mydirectory/R2.fastq -m 20000 -M 80000 -g Escherichia -o /mydirectory/my_output2`


I can filter based upon the SPAdes k-mer coverage value (-cov / --min_SPAdes_cov) if the assembly is done using SPAdes. I can also filter for base coverage (-c / --min_coverage). Following up on the example above, I’d like only those contigs with a SPAdes k-mer coverage value > 10.  
`python peasant.py -a spades -p /mydirectory/R1.fastq /mydirectory/R2.fastq -m 20000 -M 80000 -cov 10 -g Escherichia -o /mydirectory/my_output3`


Single end reads can also be considered:  
`python peasant.py -a spades -s /mydirectory/myReads.fastq -g Escherichia -o /mydirectory/my_output3`


If you’re not sure which taxa would be best to annotate your genome, you can select more than one, e.g.,  
`python peasant.py -a spades -p /mydirectory/R1.fastq /mydirectory/R2.fastq -g Escherichia Salmonella Shigella -o /mydirectory/my_output4`


I can also create my own repository (blast database) for annotation, e.g.,  
`python peasant.py -a spades -p /mydirectory/R1.fastq /mydirectory/R2.fastq -g myTaxa -o /mydirectory/my_output5`


I can also provide an assembly. Let’s say it’s a file called myAssembly.fasta. Just as if I were going to run the assembly here, I can also include filters. Note, the SPAdes k-mer coverage value (cov) cannot be used if the assembly file is provided. The base coverage (-c / --min_coverage) can be used but only if reads are provided.   
`python peasant.py -A /mydirectory/myAssembly.fasta -p /mydirectory/R1.fastq /mydirectory/R2.fastq -c 10 -g Escherichia -o /mydirectory/my_output6`


## Authors
* Jonathon Brenner
* Thomas Hatzopoulos
* Laurynas Kalesinskas
* Catherine Putonti

## License

This project is licensed under the MIT License
